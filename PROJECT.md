# Hydrix VM Automation Project

**Implementation**: Extend ~/dotfiles (not a new repo!)
**Current Foundation**: ~/dotfiles (main NixOS configs - **build from this!**)
**Current VM Builder**: ~/splix (reference implementation for VM automation)
**Date**: 2025-11-26

---

## Executive Summary

**The Big Idea**: Stop rebuilding monolithic VM images. Instead:
1. Build tiny base images once (~800MB vs 10GB)
2. VMs "shape" themselves on first boot by cloning your dotfiles repo
3. Updates happen via `git pull` inside the VM
4. Reuse your existing dotfiles modules (no duplication!)

**Key Change from Current Splix Approach**:
- ❌ **Old**: `pentest-vm-full` builds everything into image (10GB, requires rebuild for any change)
- ✅ **New**: `pentest-vm-base` is minimal (800MB), then VM runs `git clone` + `nixos-rebuild` on first boot
- ✅ **Critical Fix**: VMs get REAL git clone WITH .git directory (can `git pull` for updates!)

**Implementation Strategy**:
- **Don't create ~/Hydrix as new repo**
- **Extend ~/dotfiles** with VM building capabilities
- Keep your working mono-flake structure, just add VM profiles

---

## Project Vision

Build a modular, maintainable VM automation system where:
- **Minimal base images** are built once and stay small
- **VMs self-configure** on first boot by pulling from git
- **Updates propagate** via git pull instead of host rebuilds
- **Profiles inherit** common configurations using a mono-flake approach

---

## Current Setup Overview

### Repository Relationships

```
~/dotfiles/                          ← MAIN NixOS configuration (FOUNDATION)
├── flake.nix                        # Mono-flake with host configs
├── modules/
│   ├── configuration.nix            # Base system config
│   ├── i3.nix, packages.nix, etc.   # Shared modules
│   ├── zephyrus.nix                 # Host-specific configs
│   ├── zenbook.nix
│   ├── razer.nix
│   └── router-generated/            # VM configs generated by splix
│       ├── zephyrus-consolidated.nix  # Current working VM setup
│       └── zephyrus-passthrough.nix
└── scripts/bash/
    └── nixbuild.sh                  # Build/switch system configs

~/splix/                             ← VM building experiments
├── flake.nix                        # VM image builder
├── scripts/setup.sh                 # Full automation workflow
├── modules/router-vm-config.nix     # Router VM definition
├── pentest-vm/                      # Pentest VM configs
└── generated/                       # Generated configs (copied to ~/dotfiles)

~/Hydrix/                            ← NEW unified system (target)
└── (To be designed - combines best of both)
```

### Current Workflow

1. **Host Configuration** (~/dotfiles):
   ```bash
   cd ~/dotfiles
   ./scripts/bash/nixbuild.sh        # Build and switch host config
   # Uses: flake.nix with multiple hosts (zephyrus, razer, zenbook, etc.)
   ```

2. **VM Building** (~/splix):
   ```bash
   cd ~/splix
   ./scripts/setup.sh                # Build VMs, generate configs
   # Output: Copies generated configs to ~/dotfiles/modules/router-generated/
   ```

3. **Integration**:
   - Splix generates `zephyrus-consolidated.nix`
   - Manual copy/paste into `~/dotfiles/modules/zephyrus.nix`
   - Rebuild host with `nixbuild.sh` to activate VM specializations

### What's Already Working (~/dotfiles)

✓ **Mono-flake structure**: Multiple hosts sharing modules
```nix
# ~/dotfiles/flake.nix
nixosConfigurations = {
  zephyrus = nixpkgs.lib.nixosSystem {
    modules = [
      ./modules/configuration.nix      # Shared base
      ./modules/zephyrus.nix           # Host-specific
      ./modules/i3.nix                 # Shared UI
      ./modules/packages.nix           # Shared packages
      # ... more shared modules
    ];
  };

  razer = nixpkgs.lib.nixosSystem {
    modules = [
      ./modules/configuration.nix      # Same shared base!
      ./modules/razer.nix              # Different host-specific
      ./modules/i3.nix                 # Same shared UI!
      # ... reuses same modules
    ];
  };
};
```

✓ **Module inheritance**: DRY principle already applied
✓ **Centralized management**: Single repo for all hosts
✓ **Working build system**: `nixbuild.sh` handles machine detection

### What Needs Improvement

✗ **VM configs separate from main flake**: Two flakes (dotfiles + splix)
✗ **Manual integration**: Copy-paste generated configs
✗ **No git in VMs**: Dotfiles copied without .git directory
✗ **Monolithic VM images**: Full rebuilds for any change

---

## Current Problems (Splix + Dotfiles Integration)

### 1. Monolithic VM Images
```nix
# Current: pentest-vm-full builds EVERYTHING into the image
pentest-vm-full = nixosGenerate {
  modules = [
    ./pentest-vm/pentest-vm-config.nix
    ./pentest-vm/pentest-vm-dotfiles-config.nix  # Bakes in all dotfiles
  ];
};
```
**Problem**: Any package/config change requires complete VM rebuild (~5-10GB images)

### 2. Dotfiles Without Git
```nix
# Current: Copies dotfiles but strips .git directory
environment.etc."dotfiles-template".source = dotfiles;
# Result: /home/traum/dotfiles has NO .git directory
# Cannot: git pull, git status, track changes
```
**Problem**: VMs have static dotfiles snapshot, not a living git repository

### 3. No Inheritance/Reusability
- Router VM config: standalone
- Pentest VM config: standalone
- Future comms/browsing/dev VMs: would also be standalone
**Problem**: Duplicated code, no shared base modules

---

## Hydrix Design Philosophy: Build on Dotfiles Foundation

### Key Insight
**Don't start from scratch - extend what already works!**

Your `~/dotfiles` repo already has:
- ✓ Mono-flake with inheritance
- ✓ Shared module system
- ✓ Multiple host configurations
- ✓ Working build automation

### Hydrix Should
1. **Extend the dotfiles flake** to include VM image building
2. **Keep the module structure** you already use
3. **Add VM-specific modules** alongside existing host modules
4. **Leverage existing patterns** (same inheritance approach)

### Migration Strategy Options

#### Option A: Merge into ~/dotfiles (Recommended)
```
~/dotfiles/                      ← Extend existing repo
├── flake.nix                    # EXTEND with VM image outputs
├── modules/
│   ├── (existing host modules)
│   ├── vm/                      # NEW: VM-specific modules
│   │   ├── base.nix
│   │   ├── graphical.nix
│   │   └── shaping.nix
│   └── router-generated/        # Keep existing
├── profiles/                    # NEW: VM type profiles
│   ├── router-vm.nix
│   ├── pentest-base.nix
│   ├── pentest-full.nix
│   └── comms-full.nix
└── scripts/
    ├── bash/
    │   └── nixbuild.sh          # EXTEND for VM building
    └── vm/                      # NEW: VM scripts
        ├── build-vm.sh
        └── deploy-vm.sh
```

#### Option B: Keep Hydrix Separate (Alternative)
```
~/dotfiles/                      ← Host configs only
~/Hydrix/                        ← VM system only
  ├── flake.nix                  # VM building + profiles
  └── (imports modules from ~/dotfiles via flake input)
```

**Recommendation**: Option A - extend dotfiles
- Single source of truth
- Reuse existing module patterns
- Less duplication
- Easier to maintain

---

## New Architecture: Minimal Base + Shaping

### Build Phase (Fast, Small Images)
```
┌─────────────────────────────────────┐
│  nix build .#router-vm              │  ~500MB
│  nix build .#pentest-vm-base        │  ~800MB (core only)
│  nix build .#comms-vm-base          │  ~600MB (core only)
│  nix build .#browsing-vm-base       │  ~700MB (core only)
└─────────────────────────────────────┘
         │
         ▼ Fast builds (minutes, not hours)
```

**Base images contain**:
- NixOS core system
- Essential packages (git, nix, networking)
- First-boot shaping service
- SSH/console access
- **NO**: Full application suites, dotfiles, specialized tools

### Deploy Phase (Install to Libvirt)
```bash
./build-and-deploy.sh --type pentest --name grief --bridge virbr2
# Creates VM: pentest-grief
# Hostname: pentest-grief (used for profile detection)
```

### First-Boot Shaping Phase (Automatic)
```
VM Boots → Detects hostname → Clones git repo → Applies profile → Reboot
   │              │                   │                │             │
   │         "pentest-grief"    ~/config/.git    nixos-rebuild   Ready!
   │                                  │                │
   │                            (REAL git repo)  (Full packages)
```

**Shaping script** (runs once on first boot):
```bash
#!/usr/bin/env bash
HOSTNAME=$(hostname)
VM_TYPE=${HOSTNAME%%-*}  # Extract "pentest" from "pentest-grief"

# Clone actual git repository (with .git!)
git clone https://github.com/borttappat/Hydrix.git /etc/nixos/hydrix

# Apply profile based on VM type
cd /etc/nixos/hydrix
nixos-rebuild switch --flake .#vm-${VM_TYPE}

# Mark as shaped
touch /etc/nixos/.hydrix-shaped
```

**Result**: VM now has:
- Full application suite for its type
- REAL git repository (can `git pull` for updates)
- Always up-to-date with latest configs

---

## Extended Mono-Flake Architecture

### Extend Existing Dotfiles Flake with VM Building

```nix
# ~/dotfiles/flake.nix (EXTENDED from current structure)
{
  description = "Griefhounds NixOS configuration + VM Automation";

  inputs = {
    nixpkgs.url = "github:nixos/nixpkgs/nixos-25.05";
    nixpkgs-unstable.url = "github:nixos/nixpkgs/nixos-unstable";
    nix-index-database.url = "github:Mic92/nix-index-database";
    home-manager.url = "github:nix-community/home-manager";

    # NEW: Add nixos-generators for VM building
    nixos-generators = {
      url = "github:nix-community/nixos-generators";
      inputs.nixpkgs.follows = "nixpkgs";
    };
  };

  outputs = { self, nixpkgs, nixos-generators, ... }@inputs: {

    # ========== EXISTING: Host Configurations ==========
    nixosConfigurations = {
      # Keep existing: zephyrus, razer, zenbook, xmg, asus, etc.
      zephyrus = nixpkgs.lib.nixosSystem { ... };  # Existing config
      razer = nixpkgs.lib.nixosSystem { ... };     # Existing config

      # NEW: Full VM profiles (for post-shaping)
      vm-pentest = nixpkgs.lib.nixosSystem {
        modules = [
          ./modules/vm/base.nix           # NEW: VM base module
          ./modules/vm/graphical.nix      # NEW: VM graphical module
          ./profiles/pentest-full.nix     # NEW: Full pentest profile
          ./modules/configuration.nix     # REUSE: Existing base config!
          ./modules/i3.nix                # REUSE: Existing i3 setup!
          ./modules/packages.nix          # REUSE: Existing packages!
        ];
      };

      vm-comms = nixpkgs.lib.nixosSystem {
        modules = [
          ./modules/vm/base.nix
          ./modules/vm/graphical.nix
          ./profiles/comms-full.nix
          ./modules/configuration.nix     # REUSE existing!
          ./modules/i3.nix                # REUSE existing!
        ];
      };
    };

    # ========== NEW: VM Base Image Outputs ==========
    packages.x86_64-linux = {
      # NEW: Minimal VM base images
      router-vm = nixos-generators.nixosGenerate {
        system = "x86_64-linux";
        modules = [ ./profiles/router-vm.nix ];
        format = "qcow";
      };

      pentest-vm-base = nixos-generators.nixosGenerate {
        system = "x86_64-linux";
        modules = [
          ./modules/vm/base.nix           # Minimal VM base
          ./profiles/pentest-base.nix     # Minimal pentest prep
        ];
        format = "qcow";
      };

      comms-vm-base = nixos-generators.nixosGenerate {
        system = "x86_64-linux";
        modules = [
          ./modules/vm/base.nix
          ./modules/vm/graphical.nix      # GUI needed for Signal
          ./profiles/comms-base.nix
        ];
        format = "qcow";
      };
    };

    # ========== REUSABLE MODULES (Can be used by both hosts and VMs) ==========
    nixosModules = {
      # NEW: VM-specific modules
      vm-base = ./modules/vm/base.nix;
      vm-graphical = ./modules/vm/graphical.nix;
      vm-shaping = ./modules/vm/shaping.nix;
    };
  };
}
```

### Inheritance Example - Reusing Dotfiles Modules

```nix
# modules/vm/base.nix (NEW - SHARED by all VMs, lightweight)
{ config, pkgs, ... }: {
  # VM-specific essentials only
  boot.initrd.availableKernelModules = [ "virtio_blk" "virtio_net" ];
  services.qemuGuest.enable = true;
  nix.settings.experimental-features = [ "nix-command" "flakes" ];

  environment.systemPackages = with pkgs; [
    git vim wget curl htop
  ];

  # First-boot shaping service
  systemd.services.hydrix-shape = {
    description = "First-boot VM shaping";
    wantedBy = [ "multi-user.target" ];
    script = ''
      if [ ! -f /etc/nixos/.shaped ]; then
        /usr/local/bin/shape-vm.sh
      fi
    '';
  };
}
```

```nix
# profiles/pentest-base.nix (Minimal base image)
{ config, pkgs, ... }: {
  imports = [
    ../modules/vm/base.nix  # NEW VM base
  ];

  networking.hostName = "pentest-base";

  # Only prep work, no tools yet
  boot.kernelPackages = pkgs.linuxPackages_latest;
  environment.systemPackages = with pkgs; [ python3 go ];
}
```

```nix
# profiles/pentest-full.nix (Applied AFTER shaping - REUSES existing modules!)
{ config, pkgs, ... }: {
  imports = [
    ../modules/vm/base.nix        # NEW: VM essentials
    ../modules/vm/graphical.nix   # NEW: VM graphical setup
    ../modules/configuration.nix  # REUSE: Your existing base config!
    ../modules/i3.nix             # REUSE: Your existing i3 setup!
    ../modules/packages.nix       # REUSE: Your existing packages!
    ../modules/pentesting.nix     # REUSE: Your existing pentesting tools!
    ../modules/proxychains.nix    # REUSE: Your existing proxychains setup!
  ];

  # Override hostname for VM
  networking.hostName = lib.mkForce "pentest-vm";

  # Any pentest-specific additions
  environment.systemPackages = with pkgs; [
    # Additional tools beyond what's in modules/pentesting.nix
  ];
}
```

**Key Point**: Most of the pentest-full.nix is just importing your existing modules! No duplication!

---

## Pre-Work Tasks (Building on ~/dotfiles)

### Phase 1: Extend Dotfiles Structure
Rather than creating a new repo, extend your existing ~/dotfiles:

#### Task 1.1: Add VM-Specific Directories
```bash
cd ~/dotfiles

# Create VM module directories
mkdir -p modules/vm
mkdir -p profiles

# Create initial VM modules
touch modules/vm/base.nix         # VM essentials
touch modules/vm/graphical.nix    # VM graphical setup
touch modules/vm/shaping.nix      # First-boot shaping service

# Create VM profiles
touch profiles/router-vm.nix      # Router VM (migrate from splix)
touch profiles/pentest-base.nix   # Pentest minimal
touch profiles/pentest-full.nix   # Pentest full (imports existing modules!)
touch profiles/comms-base.nix     # Comms minimal
touch profiles/comms-full.nix     # Comms full
```

#### Task 1.2: Extend Dotfiles Flake
```bash
cd ~/dotfiles

# Add nixos-generators to flake inputs
# (Edit flake.nix to add nixos-generators input)

# Add VM image build outputs
# (Edit flake.nix packages section)
```

```nix
# In ~/dotfiles/flake.nix inputs section, ADD:
nixos-generators = {
  url = "github:nix-community/nixos-generators";
  inputs.nixpkgs.follows = "nixpkgs";
};

# In outputs section, ADD packages:
packages.x86_64-linux = {
  pentest-vm-base = nixos-generators.nixosGenerate {
    system = "x86_64-linux";
    modules = [ ./profiles/pentest-base.nix ];
    format = "qcow";
  };
};
```

```bash
# Test minimal base build
cd ~/dotfiles
nix build .#pentest-vm-base
# Verify: Result should be <1GB (vs current 10GB pentest-vm-full)
```

#### Task 1.3: Implement Shaping Service with Git Clone
```nix
# modules/vm/shaping.nix (NEW file)
{ config, pkgs, ... }: {
  systemd.services.vm-shape = {
    description = "First-boot VM shaping - clone dotfiles and apply profile";
    wantedBy = [ "multi-user.target" ];
    after = [ "network-online.target" ];

    serviceConfig = {
      Type = "oneshot";
      RemainAfterExit = true;
    };

    script = ''
      #!/usr/bin/env bash
      set -euo pipefail

      HOSTNAME=$(hostname)
      VM_TYPE=''${HOSTNAME%%-*}  # Extract "pentest" from "pentest-grief"

      # Clone dotfiles repo WITH .git directory (CRITICAL!)
      if [ ! -d /home/traum/dotfiles/.git ]; then
        echo "Cloning dotfiles repository with git history..."
        git clone https://github.com/borttappat/dotfiles.git /home/traum/dotfiles
        chown -R traum:users /home/traum/dotfiles

        # Verify .git exists
        if [ -d /home/traum/dotfiles/.git ]; then
          echo "SUCCESS: .git directory exists - can git pull for updates!"
        else
          echo "ERROR: .git directory missing!"
          exit 1
        fi
      fi

      # Apply full VM profile based on hostname
      echo "Applying full profile for VM type: $VM_TYPE"
      nixos-rebuild switch --flake /home/traum/dotfiles#vm-$VM_TYPE

      # Mark as shaped
      touch /etc/nixos/.vm-shaped
      echo "VM shaping completed!"
    '';
  };
}
```

#### Task 1.4: Test Shaping in Live VM
```bash
cd ~/dotfiles

# Build minimal VM
nix build .#pentest-vm-base

# Deploy it using splix deploy script
cd ~/splix
./scripts/deploy-pentest-vm-auto.sh \
  --image ~/dotfiles/result/nixos.qcow2 \
  --name test-shaping

# SSH into VM
ssh traum@192.168.101.X

# CRITICAL TEST: Check if dotfiles has .git
ls -la ~/dotfiles/.git  # Should exist!
git -C ~/dotfiles status # Should work!
git -C ~/dotfiles log    # Should show commit history!

# Test git pull works
cd ~/dotfiles
git pull  # Should work! (vs old approach which failed)
```

### Phase 2: Finalize Dotfiles Extension

#### Task 2.1: Update Dotfiles File Structure
```bash
cd ~/dotfiles

# After Phase 1, your structure should be:
tree -L 2
```

Expected structure:
```
~/dotfiles/                          # EXTENDED (not replaced!)
├── flake.nix                        # EXTENDED with VM outputs
├── flake.lock
├── modules/
│   ├── (all existing modules)       # KEEP existing
│   ├── vm/                          # NEW
│   │   ├── base.nix
│   │   ├── graphical.nix
│   │   └── shaping.nix
│   └── router-generated/            # KEEP existing
├── profiles/                        # NEW
│   ├── router-vm.nix
│   ├── pentest-base.nix
│   ├── pentest-full.nix
│   ├── comms-base.nix
│   └── comms-full.nix
└── scripts/
    ├── bash/
    │   └── nixbuild.sh              # KEEP existing
    └── vm/                          # NEW (optional - port from splix)
        ├── build-vm.sh
        └── deploy-vm.sh
```

#### Task 2.2: Port Components from Splix
From `~/splix` to `~/dotfiles`:
- ✓ Router VM config → `profiles/router-vm.nix`
- ✓ Hardware detection → `scripts/vm/hardware-identify.sh`
- ✓ Deployment scripts → `scripts/vm/`
- ✓ Templates (if still needed) → `templates/`

---

## Migration Workflow

### Step 1: Build Minimal Base
```bash
cd ~/Hydrix
nix build .#pentest-vm-base
# Result: ~/Hydrix/result/nixos.qcow2 (~800MB)
```

### Step 2: Deploy with Hostname Convention
```bash
./scripts/deploy-vm.sh \
  --type pentest \
  --name grief \
  --image result/nixos.qcow2 \
  --bridge virbr2

# Creates VM with hostname: "pentest-grief"
```

### Step 3: VM First Boot (Automatic Shaping)
```
1. VM boots with hostname "pentest-grief"
2. Shaping service detects VM type: "pentest"
3. Clones ~/Hydrix to /etc/nixos/hydrix (WITH .git!)
4. Runs: nixos-rebuild switch --flake /etc/nixos/hydrix#vm-pentest
5. Installs all pentest tools
6. Links dotfiles from git clone (also WITH .git!)
7. Marks as shaped: /etc/nixos/.hydrix-shaped
8. Reboots into full pentest environment
```

### Step 4: Future Updates (Git-Based)
```bash
# SSH into VM
ssh traum@pentest-grief

# Update system config
cd /etc/nixos/hydrix
git pull
nixos-rebuild switch --flake .#vm-pentest

# Update dotfiles
cd ~/dotfiles
git pull
./scripts/bash/links.sh  # Re-link if needed
```

---

## Benefits of New Approach

### 1. Fast Iteration
- **Before**: 10GB rebuild for one package change (30+ min)
- **After**: `git pull && nixos-rebuild` in VM (5 min)

### 2. Always Up-to-Date
- **Before**: Static snapshot of dotfiles (no .git)
- **After**: Live git repos in VMs, can pull latest

### 3. Code Reusability
- **Before**: Duplicate configs for each VM type
- **After**: Shared modules, profile inheritance

### 4. Smaller Builds
- **Before**: 10GB pentest-vm-full
- **After**: 800MB pentest-vm-base (shaping happens at runtime)

### 5. Flexibility
```bash
# Quick experimentation
./deploy-vm.sh --type pentest --name test-burp
# Install, test Burp Suite, destroy
virsh destroy test-burp && virsh undefine test-burp
# No 10GB rebuild needed!
```

---

## Success Criteria

### Phase 1 (Dotfiles Extension - Validation)
- [ ] VM directories created in ~/dotfiles (modules/vm/, profiles/)
- [ ] nixos-generators added to dotfiles flake
- [ ] Minimal base VM builds successfully (<1GB vs 10GB current)
- [ ] Shaping service clones dotfiles WITH .git directory
- [ ] Can `git pull` inside shaped VM (critical improvement!)
- [ ] Full profile applies correctly during shaping
- [ ] Existing host configs (zephyrus, razer) still work

### Phase 2 (VM System Complete)
- [ ] Router VM migrated to profiles/router-vm.nix
- [ ] Pentest VM working (base + full profiles)
- [ ] Comms VM working (base + full profiles)
- [ ] Module reuse confirmed (pentest-full imports existing pentesting.nix)
- [ ] VM updates via git pull tested and working

### Phase 3 (Full Integration)
- [ ] All VM types operational (router, pentest, comms, browsing, dev)
- [ ] Host specializations (maximalism mode) working
- [ ] Splix scripts ported or deprecated
- [ ] Documentation updated in ~/dotfiles
- [ ] Splix repo archived with notes pointing to dotfiles

---

## Key Technical Decisions

### 1. Hostname-Based Profile Detection
```
VM Hostname: "pentest-grief"
             └─┬──┘  └─┬─┘
          VM Type    Instance Name

Profile Selection: vm-${VM_TYPE} → vm-pentest
```

### 2. Git Clone Strategy
```nix
# OLD (Splix): Copy without .git
environment.etc."dotfiles-template".source = dotfiles;

# NEW (Hydrix): Clone with .git
script = ''
  git clone https://github.com/borttappat/dotfiles.git /home/traum/dotfiles
  # NOW: .git directory exists!
  # NOW: git pull works!
'';
```

### 3. Two-Stage Configuration
```
Stage 1: Base Image (Built with Nix)
  └─> profiles/base/pentest-base.nix

Stage 2: Full Profile (Applied at runtime)
  └─> profiles/full/pentest-full.nix
```

---

## Next Actions

1. **Create PROJECT.md** in splix repo (this document) ✓
2. **Validate approach** with minimal VM build in splix
3. **Test git clone** with .git directory preservation
4. **Create Hydrix repo** and structure
5. **Migrate router VM** as proof of concept
6. **Iterate** on remaining VM types

---

## Questions to Resolve

- [ ] **Repo strategy**: Keep ~/dotfiles name or rename to ~/Hydrix?
  - **Option A**: Keep ~/dotfiles, just extend it (simpler, maintains history)
  - **Option B**: Rename to ~/Hydrix (clearer purpose, fresh start)
  - **Recommendation**: Keep ~/dotfiles, add "Hydrix" as project name in docs

- [ ] **Git clone method**: HTTPS or SSH keys for VM shaping?
  - HTTPS: Works without setup, but public repos only
  - SSH: Requires key setup in base image, works with private repos
  - **Recommendation**: Start with HTTPS (public repo), add SSH option later

- [ ] **Shaping trigger**: Automatic on first boot vs. manual?
  - Automatic: Convenient, but requires network on first boot
  - Manual: More control, can inspect base VM first
  - **Recommendation**: Automatic with flag file to skip if needed

- [ ] **Router VM timing**: Network access during shaping?
  - Problem: Router VM might not be ready when pentest VM boots
  - **Solution**: Base image has minimal network stack, can reach internet directly for initial git clone

- [ ] **Fallback strategy**: What if git clone fails?
  - Option 1: VM stays in base state, manual recovery
  - Option 2: Retry service that keeps trying
  - **Recommendation**: Mark as "shaping-failed", create recovery script

- [ ] **Dotfiles repo visibility**: Keep private or make public?
  - Current: github.com/borttappat/dotfiles (check if private)
  - VMs need access to clone
  - **Consider**: Separate public VM configs from private host configs

---

## Project Naming

### "Hydrix" as Concept, Not Repo Name

**Decision**: Use "Hydrix" as the **project/architecture name**, but implement in **~/dotfiles**

**Rationale**:
- ~/dotfiles already has working mono-flake structure
- Preserves git history and existing workflows
- Less disruptive migration
- Can still call it "Hydrix VM Automation System" in documentation

**Implementation**:
```bash
# Repo location
~/dotfiles/  # Keep existing repo

# But document as:
# "Hydrix VM Automation System - Implemented in ~/dotfiles"
```

**Splix Future**:
- Archive ~/splix after migration
- Add README: "This project has been integrated into ~/dotfiles as the Hydrix VM Automation System"
- Keep as reference for hardware detection logic

---

**Document Status**: Initial comprehensive draft
**Next Review**: After Phase 1 validation (minimal base VM build + git clone test)
**Action Items**:
1. Review and approve approach
2. Start Phase 1 Task 1.1 (create VM directories in ~/dotfiles)
3. Test minimal base build
4. Validate git clone with .git preservation

# Consolidated Machine Configuration for zephyrus
# Generated by machine-kickstart-v2.sh on Wed Nov 26 12:24:47 CET 2025
# Contains: Conditional VFIO passthrough + Router services + Maximalism specialization
# Hardware: 8086:a370 (00:14.3)
# Base mode: Normal WiFi/network operation (VFIO disabled)
# Router/Maximalism modes: VFIO passthrough enabled for VM isolation

{ config, lib, pkgs, ... }:
let
  # Detect if we're in router or maximalism mode
  isRouterMode = config.system.nixos.label == "router-setup" || config.system.nixos.label == "maximalism-setup";
in
{
  # ===== VFIO PASSTHROUGH CONFIGURATION (Conditional - only for router/maximalism) =====
  boot.kernelParams = lib.mkIf isRouterMode [
    "intel_iommu=on"
    "iommu=pt"
    "vfio-pci.ids=8086:a370"
  ];

  boot.kernelModules = lib.mkIf isRouterMode [ "vfio" "vfio_iommu_type1" "vfio_pci" ];

  # Enable libvirtd (always available for VM management, but VFIO only in router modes)
  virtualisation.libvirtd = {
    enable = true;
    qemu = {
      package = lib.mkForce pkgs.qemu_kvm;
      runAsRoot = true;
      swtpm.enable = true;
      ovmf = {
        enable = true;
        packages = [ pkgs.OVMFFull.fd ];
      };
    };
  };

  # ===== ROUTER SPECIALIZATION =====
  specialisation.router.configuration = {
    system.nixos.label = lib.mkForce "router-setup";

    # Router mode: WiFi blacklisted for passthrough
    boot.blacklistedKernelModules = [ "iwlwifi" ];

    # Router networking bridges
    networking.bridges.virbr1.interfaces = [];
    networking.interfaces.virbr1 = {
      ipv4.addresses = [{
        address = "192.168.100.1";
        prefixLength = 24;
      }];
    };

    networking.bridges.virbr2.interfaces = [];
    networking.interfaces.virbr2 = {
      ipv4.addresses = [{
        address = "192.168.101.1";
        prefixLength = 24;
      }];
    };

    networking.bridges.virbr3.interfaces = [];
    networking.interfaces.virbr3 = {
      ipv4.addresses = [{
        address = "192.168.102.1";
        prefixLength = 24;
      }];
    };

    networking.bridges.virbr4.interfaces = [];
    networking.interfaces.virbr4 = {
      ipv4.addresses = [{
        address = "192.168.103.1";
        prefixLength = 24;
      }];
    };

    networking.bridges.virbr5.interfaces = [];
    networking.interfaces.virbr5 = {
      ipv4.addresses = [{
        address = "192.168.104.1";
        prefixLength = 24;
      }];
    };

    # Default route through router VM
    networking.defaultGateway = {
      address = "192.168.100.253";
      interface = "virbr1";
    };

    # Firewall rules for bridge networking
    networking.firewall = {
      extraCommands = ''
        # Management bridge (virbr1)
        iptables -A FORWARD -i virbr1 -j ACCEPT
        iptables -A FORWARD -o virbr1 -j ACCEPT
        iptables -t nat -A POSTROUTING -s 192.168.100.0/24 -j MASQUERADE

        # VM network bridges (virbr2-virbr5)
        iptables -A FORWARD -i virbr2 -j ACCEPT
        iptables -A FORWARD -o virbr2 -j ACCEPT
        iptables -A FORWARD -i virbr3 -j ACCEPT
        iptables -A FORWARD -o virbr3 -j ACCEPT
        iptables -A FORWARD -i virbr4 -j ACCEPT
        iptables -A FORWARD -o virbr4 -j ACCEPT
        iptables -A FORWARD -i virbr5 -j ACCEPT
        iptables -A FORWARD -o virbr5 -j ACCEPT

        # Allow inter-bridge communication through router VM
        iptables -A FORWARD -i virbr2 -o virbr1 -j ACCEPT
        iptables -A FORWARD -i virbr1 -o virbr2 -j ACCEPT
        iptables -A FORWARD -i virbr3 -o virbr1 -j ACCEPT
        iptables -A FORWARD -i virbr1 -o virbr3 -j ACCEPT
        iptables -A FORWARD -i virbr4 -o virbr1 -j ACCEPT
        iptables -A FORWARD -i virbr1 -o virbr4 -j ACCEPT
        iptables -A FORWARD -i virbr5 -o virbr1 -j ACCEPT
        iptables -A FORWARD -i virbr1 -o virbr5 -j ACCEPT
      '';
      trustedInterfaces = [ "virbr1" "virbr2" "virbr3" "virbr4" "virbr5" ];
    };

    # Router VM autostart service
    systemd.services.router-vm-autostart = {
      description = "Auto-start router VM with WiFi passthrough";
      after = [
        "libvirtd.service"
        "network.target"
        "network-online.target"
      ];
      wants = [ "libvirtd.service" "network-online.target" ];
      wantedBy = [ "multi-user.target" ];
      serviceConfig = {
        Type = "oneshot";
        ExecStart = "/home/traum/Hydrix/generated/scripts/autostart-router-vm.sh";
        RemainAfterExit = true;
        User = "root";
        TimeoutStartSec = "120s";
        Environment = "PATH=/run/current-system/sw/bin:/run/current-system/sw/sbin";
      };
    };

    # Router status command
    environment.systemPackages = with pkgs; lib.mkAfter [
      virt-manager
      (writeShellScriptBin "router-status" ''
        echo "ROUTER MODE Status"
        echo "=================="
        echo ""

        echo "Router VM Status:"
        sudo virsh list --all | grep router || echo "Router VM not found"
        echo ""

        echo "Network Status:"
        echo "  Router Bridge: $(ip link show virbr1 2>/dev/null | grep -o 'state [A-Z]*' || echo 'DOWN')"
        echo "  Default Route: $(ip route | grep default | awk '{print $5}' | head -1 || echo 'unknown')"
        echo ""

        echo "Hardware Status:"
        echo "  WiFi Blacklisted: $(lsmod | grep iwlwifi > /dev/null && echo 'NO (loaded)' || echo 'YES (blacklisted)')"
        echo "  PCI Device: 00:14.3 (8086:a370)"
        echo ""

        echo "Quick Actions:"
        echo "  Router Console: sudo virsh console router-vm-passthrough"
        echo "  VM Manager:     virt-manager"
        echo "  Switch to base: sudo nixos-rebuild switch --flake ~/dotfiles#zephyrus"
      '')
    ];
  };

  # ===== MAXIMALISM SPECIALIZATION =====
  specialisation.maximalism.configuration = {
    system.nixos.label = lib.mkForce "maximalism-setup";

    # Router configuration (inherited from router specialization)
    boot.blacklistedKernelModules = [ "iwlwifi" ];

    # Router networking bridges (duplicated for maximalism)
    networking.bridges.virbr1.interfaces = [];
    networking.interfaces.virbr1 = {
      ipv4.addresses = [{
        address = "192.168.100.1";
        prefixLength = 24;
      }];
    };

    networking.bridges.virbr2.interfaces = [];
    networking.interfaces.virbr2 = {
      ipv4.addresses = [{
        address = "192.168.101.1";
        prefixLength = 24;
      }];
    };

    networking.bridges.virbr3.interfaces = [];
    networking.interfaces.virbr3 = {
      ipv4.addresses = [{
        address = "192.168.102.1";
        prefixLength = 24;
      }];
    };

    networking.bridges.virbr4.interfaces = [];
    networking.interfaces.virbr4 = {
      ipv4.addresses = [{
        address = "192.168.103.1";
        prefixLength = 24;
      }];
    };

    networking.bridges.virbr5.interfaces = [];
    networking.interfaces.virbr5 = {
      ipv4.addresses = [{
        address = "192.168.104.1";
        prefixLength = 24;
      }];
    };

    # Default route through router VM
    networking.defaultGateway = {
      address = "192.168.100.253";
      interface = "virbr1";
    };

    # Firewall rules for bridge networking (duplicated)
    networking.firewall = {
      extraCommands = ''
        # Management bridge (virbr1)
        iptables -A FORWARD -i virbr1 -j ACCEPT
        iptables -A FORWARD -o virbr1 -j ACCEPT
        iptables -t nat -A POSTROUTING -s 192.168.100.0/24 -j MASQUERADE

        # VM network bridges (virbr2-virbr5)
        iptables -A FORWARD -i virbr2 -j ACCEPT
        iptables -A FORWARD -o virbr2 -j ACCEPT
        iptables -A FORWARD -i virbr3 -j ACCEPT
        iptables -A FORWARD -o virbr3 -j ACCEPT
        iptables -A FORWARD -i virbr4 -j ACCEPT
        iptables -A FORWARD -o virbr4 -j ACCEPT
        iptables -A FORWARD -i virbr5 -j ACCEPT
        iptables -A FORWARD -o virbr5 -j ACCEPT

        # Allow inter-bridge communication
        iptables -A FORWARD -i virbr2 -o virbr1 -j ACCEPT
        iptables -A FORWARD -i virbr1 -o virbr2 -j ACCEPT
        iptables -A FORWARD -i virbr3 -o virbr1 -j ACCEPT
        iptables -A FORWARD -i virbr1 -o virbr3 -j ACCEPT
        iptables -A FORWARD -i virbr4 -o virbr1 -j ACCEPT
        iptables -A FORWARD -i virbr1 -o virbr4 -j ACCEPT
        iptables -A FORWARD -i virbr5 -o virbr1 -j ACCEPT
        iptables -A FORWARD -i virbr1 -o virbr5 -j ACCEPT
      '';
      trustedInterfaces = [ "virbr1" "virbr2" "virbr3" "virbr4" "virbr5" ];
    };

    # Router VM autostart service (from router specialization)
    systemd.services.router-vm-autostart = {
      description = "Auto-start router VM with WiFi passthrough";
      after = [
        "libvirtd.service"
        "network.target"
        "network-online.target"
      ];
      wants = [ "libvirtd.service" "network-online.target" ];
      wantedBy = [ "multi-user.target" ];
      serviceConfig = {
        Type = "oneshot";
        ExecStart = "/home/traum/Hydrix/generated/scripts/autostart-router-vm.sh";
        RemainAfterExit = true;
        User = "root";
        TimeoutStartSec = "120s";
        Environment = "PATH=/run/current-system/sw/bin:/run/current-system/sw/sbin";
      };
    };

    # Pentest VM autostart service (in addition to router)
    systemd.services.pentest-vm-auto-autostart = {
      description = "Auto-start pentest-vm-auto pentest VM";
      after = [
        "router-vm-autostart.service"
        "libvirtd.service"
        "network.target"
        "network-online.target"
      ];
      wants = [ "router-vm-autostart.service" "libvirtd.service" "network-online.target" ];
      wantedBy = [ "multi-user.target" ];

      serviceConfig = {
        Type = "oneshot";
        RemainAfterExit = true;
        User = "root";
        TimeoutStartSec = "120s";
        Environment = "PATH=/run/current-system/sw/bin:/run/current-system/sw/sbin";
      };

      script = ''
        log() { echo "[$(date +%H:%M:%S)] Pentest VM Autostart: $*"; }

        VIRSH="/run/current-system/sw/bin/virsh"
        SYSTEMCTL="/run/current-system/sw/bin/systemctl"

        log "Starting pentest-vm-auto autostart process..."

        # Wait for router VM to be ready
        log "Waiting for router VM to be ready..."
        sleep 10

        # Ensure pentest VM image exists
        PENTEST_IMAGE_PATH="/home/traum/Hydrix/result/nixos.qcow2"
        TARGET_IMAGE="/var/lib/libvirt/images/pentest-vm-auto.qcow2"

        if [[ -f "$PENTEST_IMAGE_PATH" && ! -f "$TARGET_IMAGE" ]]; then
          log "Copying pentest VM image to libvirt images directory..."
          sudo mkdir -p /var/lib/libvirt/images
          sudo cp "$PENTEST_IMAGE_PATH" "$TARGET_IMAGE"
          if id "libvirt-qemu" >/dev/null 2>&1; then
            sudo chown libvirt-qemu:kvm "$TARGET_IMAGE"
          else
            sudo chmod 644 "$TARGET_IMAGE"
          fi
          log "Pentest VM image copied successfully"
        fi

        # Check if libvirtd is running
        if ! $SYSTEMCTL is-active --quiet libvirtd; then
          log "Starting libvirtd service..."
          $SYSTEMCTL start libvirtd
          sleep 3
        fi

        sleep 2

        # Check if VM exists
        if ! $VIRSH --connect qemu:///system list --all | grep -q "pentest-vm-auto"; then
          log "ERROR: Pentest VM 'pentest-vm-auto' not found"
          log "Please ensure the VM is properly deployed"
          exit 1
        fi

        # Check and start VM
        vm_state=$($VIRSH --connect qemu:///system list --all | grep "pentest-vm-auto" | awk '{print $3}' || echo "unknown")
        log "Pentest VM current state: $vm_state"

        case "$vm_state" in
          "running")
            log "pentest-vm-auto is already running"
            ;;
          "shut"|"shutoff")
            log "Starting pentest-vm-auto..."
            if $VIRSH --connect qemu:///system start "pentest-vm-auto"; then
              log "pentest-vm-auto started successfully"
              sleep 3
            else
              log "ERROR: Failed to start pentest-vm-auto"
              exit 1
            fi
            ;;
          *)
            log "pentest-vm-auto in unexpected state: $vm_state"
            log "Attempting to start anyway..."
            if $VIRSH --connect qemu:///system start "pentest-vm-auto"; then
              log "pentest-vm-auto started despite unexpected state"
              sleep 3
            else
              log "ERROR: Failed to start pentest-vm-auto"
              exit 1
            fi
            ;;
        esac

        # Verification
        if $VIRSH --connect qemu:///system list | grep -q "pentest-vm-auto.*running"; then
          log " [+] pentest-vm-auto is running and ready"
          log " [+] Router VM also running for network isolation"
        else
          log " [!] pentest-vm-auto startup verification failed"
          exit 1
        fi

        log "pentest-vm-auto autostart completed successfully"
      '';
    };

    # Enhanced status command for maximalism mode
    environment.systemPackages = with pkgs; lib.mkAfter [
      virt-manager

      (writeShellScriptBin "maximalism-status" ''
        echo "MAXIMALISM MODE Status"
        echo "======================"
        echo ""

        echo "Router VM Status:"
        sudo virsh list --all | grep router || echo "Router VM not found"
        echo ""

        echo "Pentest VM (pentest-vm-auto) Status:"
        sudo virsh list --all | grep "pentest-vm-auto" || echo "pentest-vm-auto not found"
        echo ""

        echo "Network Status:"
        echo "  Router Bridge: $(ip link show virbr1 2>/dev/null | grep -o 'state [A-Z]*' || echo 'DOWN')"
        echo "  Default Route: $(ip route | grep default | awk '{print $5}' | head -1 || echo 'unknown')"
        echo ""

        echo "Quick Actions:"
        echo "  Start pentest-vm-auto:         sudo virsh start pentest-vm-auto"
        echo "  Stop pentest-vm-auto:          sudo virsh shutdown pentest-vm-auto"
        echo "  Router Console:           sudo virsh console router-vm-passthrough"
        echo "  pentest-vm-auto Console:       sudo virsh console pentest-vm-auto"
        echo "  VM Manager:               virt-manager"
        echo "  Switch to router:         cd ~/dotfiles && ./scripts/bash/nixbuild.sh router-switch"
        echo "  Switch to base:           cd ~/dotfiles && ./scripts/bash/nixbuild.sh base-switch"
      '')
    ];
  };

  # ===== BASE CONFIGURATION (Always Enabled) =====
  environment.systemPackages = with pkgs; lib.mkAfter [
    virt-manager
    virt-viewer
    libvirt
    qemu
    OVMF
    spice-gtk

    # Status command for current mode detection
    (writeShellScriptBin "vm-status" ''
      echo "zephyrus VM Status"
      echo "======================"
      echo ""

      # Detect current specialisation
      if [[ -L /run/current-system/specialisation ]]; then
        ACTIVE_SPEC=$(readlink /run/current-system/specialisation | xargs basename 2>/dev/null || echo "none")
        echo "Current Mode: $ACTIVE_SPEC"
      else
        echo "Current Mode: base (no specialisation active)"
      fi
      echo ""

      echo "Available Specialisations:"
      echo "  base        - Normal laptop mode (WiFi enabled)"
      echo "  router      - Router VM only (WiFi passthrough)"
      echo "  maximalism  - Router + Pentest VMs (full setup)"
      echo ""

      echo "Quick Switch Commands:"
      echo "  cd ~/dotfiles && ./scripts/bash/nixbuild.sh base-switch"
      echo "  cd ~/dotfiles && ./scripts/bash/nixbuild.sh router-switch"
      echo "  cd ~/dotfiles && ./scripts/bash/nixbuild.sh maximalism-switch"
      echo ""

      # Show running VMs regardless of mode
      echo "Currently Running VMs:"
      sudo virsh list --name 2>/dev/null | grep -v '^$' || echo "  No VMs running"
    '')
  ];
}
